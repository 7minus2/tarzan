#!/usr/bin/env python

import sys
import struct
import tarfp
from Crypto.Hash import SHA256
import dtar

blocks_size = 10240
blocks_file_size_max = 100000000
password = 'TEST_PASSWORD'


class FileWithTarAttrs:
    def __init__(self, fp):
        self.fp = fp
        self.read = fp.read
        self.pax_headers = {}
        self.encoding = sys.getfilesystemencoding()
        self.errors = None
input_file = FileWithTarAttrs(sys.stdin)
output_file = sys.stdout
#block_storage = dtar.BlockStorage('/tmp/test.bs', password)
block_storage = dtar.BlockStorage('/dev/shm/test.bs', password)
have_brick = False

while True:
    try:
        ti = tarfp.TarInfo().fromfileobj(input_file)
    except tarfp.EOFHeaderError:
        break

    sys.stderr.write('%s size=%d\n' % (repr(ti), ti.size))

    if ti.size == 0:
        output_file.write(ti.tobuf())
        continue

    to_read = ti.size
    input_leftover = ti.size % tarfp.BLOCKSIZE
    blocks, block_leftover = divmod(ti.size, blocks_size)
    blocks += 1
    if block_leftover > 0:
        blocks += 1
    ti.size = 36 * blocks
    output_leftover = ti.size % tarfp.BLOCKSIZE

    output_file.write(ti.tobuf())
    file_hash = SHA256.new()
    while to_read:
        data = input_file.read(min(blocks_size, to_read))
        to_read -= len(data)

        hashkey = dtar.gen_hashkey(data)
        if hashkey not in block_storage.blocks_map:
            if not have_brick or (
                    block_storage.blocks_file_size
                    and block_storage.blocks_file_size > blocks_file_size_max):
                block_storage.new_brick()
                have_brick = True
            block_storage.store_block(data)

        file_hash.update(data)

        output_file.write(hashkey)

    #  whole file hash
    hash_key = file_hash.digest() + struct.pack('!L', 0)
    output_file.write(hash_key)

    #  write padding
    if output_leftover > 0:
        output_file.write('\0' * (tarfp.BLOCKSIZE - output_leftover))

    #  read trailing padding
    if input_leftover > 0:
        padding = input_file.read(tarfp.BLOCKSIZE - input_leftover)
        if padding != '\0' * len(padding):
            raise ValueError(
                'Expecting NULs, got "%s"' % repr(padding[:32]))

if have_brick:
    block_storage.close_brick()

#while True:
#   s = sys.stdin.read(tarfile.BLOCKSIZE)
#   obj = tarfile.TarInfo().frombuf(s)
#   print obj
#   print obj.path, obj.size
#   sys.stdin.read(obj.size / tarfile.BLOCKSIZE)

#import dtar
#
#os.system('rm -rf /tmp/dtartest')
#dt = dtar.Dtar('/tmp/dtartest')
#dt.create()
#idx = dt.index('Testing')
#f = dtar.DtarFile()
#f.from_file('/etc/services')
#print repr(f.format_header())
#print len(f.format_header())
