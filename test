#!/usr/bin/env python

import sys
import struct
import tarfp
from Crypto.Hash import SHA256
from Crypto.Cipher import AES
from Crypto import Random
import zlib

blocks_size = 10240
password = 'TEST_PASSWORD'


def encode_block(block, hash_key):
    block_magic = 'dt1n'
    compressed_block = zlib.compress(block)
    if len(compressed_block) < len(block):
        block = compressed_block
        block_magic = 'dt1z'

    crypto_iv = Random.new().read(32)
    crypto = AES.new(password, AES.MODE_CBC, crypto_iv)
    block = crypto.encrypt(block)

    header = (block_magic + struct.pack('!L', len(block)) + hash_key)
    return header, crypto_iv + block


class FileWithTarAttrs:
    def __init__(self, fp):
        self.fp = fp
        self.read = fp.read
        self.pax_headers = {}
        self.encoding = sys.getfilesystemencoding()
        self.errors = None
input_file = FileWithTarAttrs(sys.stdin)
output_file = sys.stdout

while True:
    try:
        ti = tarfp.TarInfo().fromfileobj(input_file)
    except tarfp.EOFHeaderError:
        break

    sys.stderr.write('%s size=%d\n' % (repr(ti), ti.size))

    if ti.size == 0:
        output_file.write(ti.tobuf())
        continue

    to_read = ti.size
    input_leftover = ti.size % tarfp.BLOCKSIZE
    blocks, block_leftover = divmod(ti.size, blocks_size)
    blocks += 1
    if block_leftover > 0:
        blocks += 1
    ti.size = 36 * blocks
    output_leftover = ti.size % tarfp.BLOCKSIZE

    output_file.write(ti.tobuf())
    file_hash = SHA256.new()
    while to_read:
        data = input_file.read(min(blocks_size, to_read))
        to_read -= len(data)

        hash = SHA256.new()
        hash.update(data)
        file_hash.update(data)

        hash_key = hash.digest() + struct.pack('!L', len(data))
        output_file.write(hash_key)

    #  whole file hash
    hash_key = file_hash.digest() + struct.pack('!L', 0)
    output_file.write(hash_key)

    #  write padding
    if output_leftover > 0:
        output_file.write('\0' * (tarfp.BLOCKSIZE - output_leftover))

    #  read trailing padding
    if input_leftover > 0:
        padding = input_file.read(tarfp.BLOCKSIZE - input_leftover)
        if padding != '\0' * len(padding):
            raise ValueError(
                'Expecting NULs, got "%s"' % repr(padding[:32]))

#while True:
#   s = sys.stdin.read(tarfile.BLOCKSIZE)
#   obj = tarfile.TarInfo().frombuf(s)
#   print obj
#   print obj.path, obj.size
#   sys.stdin.read(obj.size / tarfile.BLOCKSIZE)

#import dtar
#
#os.system('rm -rf /tmp/dtartest')
#dt = dtar.Dtar('/tmp/dtartest')
#dt.create()
#idx = dt.index('Testing')
#f = dtar.DtarFile()
#f.from_file('/etc/services')
#print repr(f.format_header())
#print len(f.format_header())
